  // ROS_ERROR("PLANNIG PATH b");
  // start at current position
  
  // int n = 0;
  // std::vector<viewpoint_t> viable_viewpoints(0);
  // viable_viewpoints.push_back(viewpoint_t{.position=current_viewpoint_, .coverage=10000});

  // // extract viewpoints from frontiers
  // {
  //   std::scoped_lock lock(mutex_frontiers_);

  //   for (auto & fis : frontier_manager_->fis_c_)
  //   {
  //     if (fis->viewpoints_.size() > 0) 
  //     {
  //       viable_viewpoints.push_back(fis->viewpoints_[0]);
  //       n++;
  //     }
  //   }
  // }  

  // ROS_INFO_THROTTLE(1.0, "[MrsExplorer]: viable viewpoints %i", viable_viewpoints.size());
  // if (viable_viewpoints.size() == 1)
  // {
  //   ROS_WARN("[MrsExplorer]: NO viable viewpoints");
  //   return false;
  // }
  
  // calculate distance matrix for global path calculation
  // Eigen::MatrixXd dist_matrix(n+1,n+1);
  // for (int i=1; i<n+1; i++ )
  // {
  //   for (int j=1; j<n+1; j++ )
  //   {
  //     dist_matrix(i,j) = viable_viewpoints[i].position.distance(viable_viewpoints[j].position);
  //   }
  //   double c = std::acos(velocity.dot(viable_viewpoints[i].position-current_viewpoint_) / ((viable_viewpoints[i].position-current_viewpoint_).norm()*velocity.norm()) );
  //   c = c >= _big_distance_/10.0 ? 0.0 : c;
  //   dist_matrix(0,i) = current_viewpoint_.distance(viable_viewpoints[i].position) + _heading_weight_*c;
  //   dist_matrix(i,0) = _big_distance_;
  //   dist_matrix(i,i) = 10*_big_distance_;
  // }
  // dist_matrix(0,0) = 10*_big_distance_;